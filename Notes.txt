First, the plan is to secure the web app. When opening localhost:5200/tictactoe, there is no security and it should be locked behind authentication (for testing purposes).

Then, I will start learning about classes of authentication and web apps, then make definitions and lists here

    Notes from 1/8 meeting:
-Focus on definitions of classes of web apps
-may not be React, could be HTML or PHP instead. React is not the whole picture. We want one app to represent the general
-Modern web apps have 2 classes: SPA and Next.js; understand the difference between the 2, might be where the rendering happens (client/server sides).
-JWT is used for distributed app (different parts from different servers). It is just the token.

JWT vs session cookie: major difference. JWT is more modern, session is classical. Same purpose, different implementations. JWT have a refresh and active token. In JWT, the server does not need to keep session/state info in the database. Makes it more flexible.
These answers will dictate which sample to choose for representative case.

In the web app, there is nothing stopping the user from going straight to tictactoe. No security for the app, needs a token system (session cookie or JWT). First focus is to make the app secure.
When I am learning/changing something big, take notes. Especially on roadblocks.

look for projects with licenses in readme -> ask chatgpt about projects we can use. Look at creative commons or GPL licenses. Usually must acknowledge source.

can make a list of sample projects (or web apps in general) of each class type, and note characteristics. Mostly focus on gaining a clear understanding so that my selection is good, so it is a representative set. Also need to talk about this in the paper, will be informative. Know characteristics.


    Updates:
    1/9/26: 
-Refactored URL system to have a default landing page, then passkey login is behind /login and tictactoe remains the same
-Also added "protected routes" and an isAuthenticated flag that is passed and updated on the backend.
-With these changes, I believe the /tictactoe page is better protected. Need to do more testing to see if it is 100% secure
My next goal is to implement a session token or JWT system to preserve login info for a short period of time

    1/14: 
-got new laptop, transferred system over and got MYSQL updated and working here as well

    1/15:
-started with improving the old system to give a JWT token for session persistence. 
-Uses the JsonWebToken library, creates a token based on your email and userID (encrypted). 
-Frontend saves and references this token (and user email for game display), Backend recalculates for verification
-Note that this particular JWT token system is based on a secret key that is kept on the backend, which is very insecure. 
Real web apps use an environment variable that store randomly-generated crypto keys. They may be static for as long as the server runs, or rotated often (every 30 days for example)
-Frontend saves it for 7 days, very easy to change (Server.js "expiresIn" tag)
-also tweaked/refactored URL handling system to take this token into account (e.g. skip login page if token exists)
All of this was very simple and had very minimal issues thanks to github copilot, took not even an hour
    New routing system:
-if token exists: if you go to login page, automatically route to tictactoe. Can also directly access tictactoe
-if no token exists: login page works as normal, and you cannot access tictactoe
-Clicking "log out" on tictactoe page deletes JWT data (token/email) from browser memory

    New command for building/deployment:
//this script builds frontend and copies build files into backend automatically:
npm run deploy 
//Then just start the backend:
npm run start-backend

    Web app type research
11-ish categories of web apps (static, dynamic, single-page, multi-page, etc.), often overlap/combine
4 main classifications of how web apps are supplied to users: server-side rendering, client-side rendering, static-site generation, incremental static regeneration
-CSR: renders mostly on client's browser. Server sends empty HTML file and JS code, then frontend uses JS (React) to build page
-SSR: Server generates full HTML/webpage and sends them to client as webpage is navigated, and minimal JS/React use. Low end computers load faster
-SSG: Generate static HTML pages at build time, then serve those pages to client upon navigation. Makes Client and Server very fast, but no dynamic content (so no login/authentication)
-ISR: combine SSG and CSR, some pages are static (cached) but others are dynamic. Not necessarily feasible for our project, usually for massive websites that change semi-often
The rendering options are dependent on the type of app, and change how fast it loads on client and server side
For authentication, SSR and CSR most relevant, and often includes a hybrid approach. SSR for authentication, CSR for things past the authentication (tictactoe)
source: https://www.youtube.com/watch?v=p02AIAoImzU

Combining the categories and classficiations into most common implementations for our project:
-Classic server-rendered apps (Rails, PHP, Django): "stateful", the active user's Session ID stored in database/cache.
Authenticates using session cookies (cookie has an ID attached to request, server checks ID for identifying user)
-SPA (React/Vue/Angular): Often "stateless", where the server doesn't keep track of user session states. 
Instead, a JWT is given to user and stored in their browser. System adds this token to all API calls for authorization on each request
This passkey project is a React SPA. JWT token is a server signature, not session ID. It may be weak to XSS because JWT is on browser
-SSR with React (Next.js): sort of a hybrid of SSR and CSR. Generate complete HTML (including JS bundles for interactions), send to user but display main page HTML immediately. 
Then start downloading/setup of React components in the background ("hydration"), so the client-side page is interactive.
Custom HTML can be provided via authentication using a cookie. If no cookie exists, route the user to the login page, which doesn't require the authentication data.
-Backend for Frontend (BFF): most secure but most complex. BFF is on the server side. 
Adds a small layer between SPA and the main API. SPA never sees token. SPA talks to the BFF ("private server"), BFF talks to identity provider.
BFF uses Secure Session Cookies to talk to SPA, but uses JWTs (server-side) to talk to the main API. Keeps tokens off browser, making token theft nearly impossible.
In simpler terms, the BFF connects the user's session cookie to their token on the backend, as well as keeping the frontend simple and handling complex calls/data on the server side.

Elaborating on notes from meeting:
-Technically there are 4 main types of web apps instead of the 2 we thought (SPA with React, and SSR with Next.js). Discussed above.
-"JWT has refresh and active token": apps use both an access token (short-lived, sent with API requests) and a refresh token (long-lived, used to get new access token, stored securely)
Current version of this app only has the long-lived token, real apps use both.
-"JWT is more modern, session is classical. Same purpose, different implementations ... In JWT, the server does not need to keep session/state info in the database. Makes it more flexible.":
I agree with this mostly, although they are widely both used right now. JWTs are faster and better for larger widely-spread website systems, where contacting multiple web servers for authentication is costly.
For small web apps with just one database, some people recommend the session ID system for simplicity and fast processing. 
-https://www.reddit.com/r/webdev/comments/1ibe6u1/jwt_vs_cookies/ 

Another key factor we need to keep in mind is how the JWT/session cookie is stored. localstorage is vulnerable to attack. 
Best practice might involve a combination of HttpOnly cookie + JWT. JWT Token rotation is also important, but not too difficult to add to a simple web app.
HttpOnly cookies are a special type of cookie that cannot be accessed by client-side scripts, preventing XSS. They are sent with HTTP requests. Set/supplied/managed by server-side.

Next step: revise/confirm my understanding/definitions, then start gathering candidates and categorize them

1/17 Meeting notes:
-try making a diagram on word document or Latex (on portal called overleaf.com)
-overleaf if used for professional research paper and documents. He will share template, and I will fill it

Background of paper: mention types of web apps, and experience with passkey flow. A few lines about JWT.
End goal of the project: Try at least 2 representative web apps, add passkey flow to both. First was this one, a web app with no authentication beforehand, and was added by Raj. Then I added JWT
-now, we are also adding a session management technique. After exploring, explain if JWT is a good option for fulfilling that goal. If yes, make JWT handle the session.
In the next week, work on figuring out if JWT is the right way to manage the session. If yes, go ahead to make it secure, and take notes/documentation. So that we are ready to write this experience as a research paper.

-what kind of Key is used in JWT? Symmetric. Might be a MAC situation, need to figure out exactly what it is. I thought it was encrypt/decrypt.
-have a diagram on how JWT is working, in the context of my app. Sign and verification. Know where the key is
-remember main question: Is JWT a viable option for securing the session? If so, learn about JWT and draw the diagram.

1/19
-the current JWT system is not secure. Key is hardcoded and weak, token is transmitted without security, and uses HS256 (hash mac symmetric key algorithm)
-Started with moving secrets to environment variables in the project. Installed the "dotenv" library, and added a ".env" file
-JWT may be symmetric (Hash MAC, current) or asymmetric (RS 256). Hash Mac works, but if the secret leaks then an attacker could bypass everything. 
In real distributed servers, there is often 1 authentication server that keeps the private key and the rest use the public key to verify.
-converted and refactored code to use cookies. 
Ideally, it also should have HTTPS instead of HTTP, but that will require a valid SSL certificate and converting server over. Need to do more research first.


1/21:
Starting to gather/categorize some open-source web apps for potential research
Three main categories I am searching for: SPA (react, vue, angular), SSR (express, rails, php, etc.), and hybrid (nextjs)

    SPA (we already did one of this category, but still helpful to look at other examples)
    Search terms: "react express authentication github", "mern authentication open source", "react jwt auth example"
https://github.com/bezkoder/react-js-login-registration-hooks/tree/master
-SPA with JWT and httpOnly cookie
https://github.com/bajuddin15/notesmaker-mern/tree/main
-SPA with MERN stack

    Hybrid
    Search terms: "nextjs authentication password", "nextjs auth example credentials", "nextjs login session cookie"
https://github.com/Mohammed-Abdelhady/nextjs-nestjs-oauth-rbac-boilerplate
-This one is very complex, but is a good hybrid (nextjs) example
https://github.com/jsguerra/nextjs-credentials-example/tree/main
-very simple nextjs password authentication example.
https://github.com/valqelyan/next-auth
-Another relatively simple nextjs authentication system. However, it uses a google-associated system. May be interesting to experiment with using passkey on this app.

    SSR
    Search terms: "node express login session", "express server side rendering authentication"
https://github.com/SajjanKarn/login_register_system_node
-SSR, uses express and nodejs. Extremely simple and bare-bones, and has a youtube tutorial on how it was made. Very good candidate
https://github.com/kjalnes/user-login-sessions/tree/master
-Also SSR with express and nodejs, but it also includes React. Very simple JWT token login app. Need to check to make sure it is SSR, but is a good candidate

    Other
https://github.com/instantcommerce/next-password-protect
-this isn't what we were looking for, but is a library to add a password prompt page to a nextjs app. Might be interesting to convert to a passkey prompt library. 


1/24/26 meeting
-try to secure local storage. In paper, it is okay to say something like "we did this, but ideally this part is left"
-can try to host this one a public server. We can do AWS, probably later
-for paper writing, lets focus on localhost for now. If the switch to https is possible, it is better.
-Let's do classical SSR, and find an app uses password-based authentication to unlock some other thing. 
-Might be best if I find an SPA web app with password-based authentication, and convert. Raj's project was adding passkey to a web app with no authentication. 
-main focus is to finish implementation of current one, and write paper. That is the goal.